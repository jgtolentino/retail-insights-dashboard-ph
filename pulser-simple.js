#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { spawn } from 'child_process';
import yaml from 'js-yaml';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Parse command line arguments
const args = process.argv.slice(2);
const command = args[0];
const taskName = args[1];

// Debug logging
const debug = process.env.PULSER_LOG_LEVEL === 'debug';
const log = (msg) => debug && console.log(`üîç [DEBUG] ${msg}`);

// Environment validation
function validateEnvironment(config) {
  const issues = [];
  
  if (config.environment && config.environment.required) {
    for (const requirement of config.environment.required) {
      try {
        // Check if command exists
        const result = spawn('which', [requirement], { stdio: 'pipe' });
        if (result.status !== 0) {
          issues.push(`Required command '${requirement}' not found in PATH`);
        }
      } catch (error) {
        issues.push(`Could not check for '${requirement}': ${error.message}`);
      }
    }
  }
  
  // Check Node.js version
  const nodeVersion = process.version;
  const majorVersion = parseInt(nodeVersion.slice(1).split('.')[0]);
  if (majorVersion < 18) {
    issues.push(`Node.js ${nodeVersion} detected. Requires Node.js 18+ for optimal compatibility`);
  }
  
  // Check for required environment variables for GitHub integration
  if (config.agents && config.agents.Claudia && !process.env.GITHUB_TOKEN) {
    log('GitHub integration available but GITHUB_TOKEN not set');
  }
  
  return issues;
}

// Load pulser.yaml
function loadConfig() {
  try {
    const configPath = path.join(process.cwd(), 'pulser.yaml');
    
    if (!fs.existsSync(configPath)) {
      console.error(`‚ùå No pulser.yaml found in current directory`);
      console.error(`   Run this command from a directory containing pulser.yaml`);
      console.error(`   Or create one with: pulser init`);
      process.exit(1);
    }
    
    const config = yaml.load(fs.readFileSync(configPath, 'utf8'));
    log(`Parsed pulser.yaml ‚Üí found ${Object.keys(config.tasks || {}).length} tasks`);
    
    // Validate environment
    const issues = validateEnvironment(config);
    if (issues.length > 0) {
      console.warn(`‚ö†Ô∏è  Environment issues detected:`);
      issues.forEach(issue => console.warn(`   ${issue}`));
      console.warn(`   Some functionality may be limited`);
    }
    
    return config;
  } catch (error) {
    if (error.name === 'YAMLException') {
      console.error(`‚ùå Invalid YAML syntax in pulser.yaml:`);
      console.error(`   ${error.message}`);
      console.error(`   Check your YAML formatting and try again`);
    } else {
      console.error(`‚ùå Error loading pulser.yaml: ${error.message}`);
    }
    process.exit(1);
  }
}

// Execute command and return structured result
async function executeCommand(cmd) {
  return new Promise((resolve) => {
    log(`Spawning: ${cmd}`);
    const child = spawn('sh', ['-c', cmd], {
      stdio: ['inherit', 'pipe', 'pipe'],
      env: { ...process.env }
    });

    let stdout = '';
    let stderr = '';

    child.stdout.on('data', (data) => {
      stdout += data.toString();
      if (debug) process.stdout.write(data);
    });

    child.stderr.on('data', (data) => {
      stderr += data.toString();
      if (debug) process.stderr.write(data);
    });

    child.on('close', (code) => {
      resolve({
        stdout: stdout.trim(),
        stderr: stderr.trim(),
        exitCode: code || 0
      });
    });

    child.on('error', (err) => {
      resolve({
        stdout: '',
        stderr: err.message,
        exitCode: 1
      });
    });
  });
}

// Claudia implementation
async function postToGitHub(prNumber, planTasks, owner = 'owner', repo = 'repo') {
  // Check for GitHub token
  if (!process.env.GITHUB_TOKEN) {
    return {
      error: 'GITHUB_TOKEN environment variable required'
    };
  }

  try {
    // Dynamic import for Octokit (ES modules)
    const { Octokit } = await import('@octokit/rest');
    const octokit = new Octokit({ 
      auth: process.env.GITHUB_TOKEN 
    });

    // Format the markdown
    const taskList = planTasks.map((task, index) => {
      const files = task.filePaths.map(f => `\`${f}\``).join(', ');
      const deps = task.deps && task.deps.length > 0 ? `\n    - Dependencies: ${task.deps.join(', ')}` : '';
      return `- [ ] **${task.name}** (${task.type})\n  - Files: ${files}${deps}`;
    }).join('\n');

    const markdown = `## ü§ñ AI Implementation Plan for PR #${prNumber}

**Generated by Pulser Maya Planning Agent**

### Tasks:
${taskList}

### Execution Order:
Execute tasks in dependency order. Mark completed tasks with [x].

---
*Generated with Pulser AI ‚Ä¢ [View Documentation](https://github.com/${owner}/${repo})*`;

    log(`Posting to GitHub: ${owner}/${repo}#${prNumber}`);
    
    // Post the comment
    const result = await octokit.rest.issues.createComment({
      owner,
      repo,
      issue_number: prNumber,
      body: markdown
    });

    return {
      commentUrl: result.data.html_url,
      commentId: result.data.id
    };

  } catch (error) {
    log(`GitHub API error: ${error.message}`);
    return {
      error: `GitHub API error: ${error.message}`
    };
  }
}

// Execute fix suggestion through Patcha agent
async function executeFixSuggestion(suggestion, category, severity, taskName, context) {
  log(`Patcha executing fix: ${suggestion} (${category}/${severity})`);
  
  // Safety checks
  const unsafePatterns = [
    /sudo|su /i,
    /rm -rf|rm -r/i,
    /\/etc\/|\/usr\/|\/sys\//i,
    /chmod 777|chmod -R 777/i,
    /mkfs\.|dd if=/i,
    /\|\s*sh|bash -c/i
  ];
  
  for (const pattern of unsafePatterns) {
    if (pattern.test(suggestion)) {
      return {
        executed: false,
        command: '',
        result: {},
        needsManualIntervention: true,
        reason: `Unsafe command detected in suggestion: ${suggestion}`
      };
    }
  }
  
  // Manual intervention patterns
  const manualPatterns = [
    /check network connection/i,
    /consult the documentation/i,
    /run with sudo/i,
    /be careful/i,
    /dns settings/i,
    /proxy configuration/i
  ];
  
  for (const pattern of manualPatterns) {
    if (pattern.test(suggestion)) {
      return {
        executed: false,
        command: '',
        result: {},
        needsManualIntervention: true,
        reason: `Manual intervention required: ${suggestion}`
      };
    }
  }
  
  // Execution patterns with safety validation
  const executionPatterns = [
    {
      regex: /Install missing module: npm install (.+)/i,
      command: (match) => `npm install ${match[1]}`,
      category: 'dependency',
      riskLevel: 'low'
    },
    {
      regex: /Install missing command: npm install -D (.+)/i,
      command: (match) => `npm install -D ${match[1]}`,
      category: 'dependency', 
      riskLevel: 'low'
    },
    {
      regex: /Install Tailwind CSS: (.+)/i,
      command: (match) => match[1],
      category: 'build',
      riskLevel: 'low'
    },
    {
      regex: /Fix file permissions: chmod \+x (.+)/i,
      command: (match) => `chmod +x ${match[1]}`,
      category: 'permissions',
      riskLevel: 'medium',
      validate: (match) => {
        const file = match[1];
        return !file.includes('..') && !file.startsWith('/') && fs.existsSync(file);
      }
    },
    {
      regex: /Port (\d+) is in use\. Kill process: (.+)/i,
      command: (match) => match[2],
      category: 'process',
      riskLevel: 'medium'
    },
    {
      regex: /Initialize git repository: (.+)/i,
      command: (match) => match[1],
      category: 'git',
      riskLevel: 'low'
    }
  ];
  
  // Try to match and execute
  for (const pattern of executionPatterns) {
    const match = suggestion.match(pattern.regex);
    if (match) {
      // Validate if pattern has validation function
      if (pattern.validate && !pattern.validate(match)) {
        return {
          executed: false,
          command: '',
          result: {},
          needsManualIntervention: true,
          reason: `Validation failed for command: ${suggestion}`
        };
      }
      
      const command = typeof pattern.command === 'function' 
        ? pattern.command(match)
        : pattern.command;
      
      log(`Executing Patcha command: ${command}`);
      
      try {
        const result = await executeCommand(command);
        
        return {
          executed: true,
          command: command,
          result: result,
          needsManualIntervention: false,
          reason: `Successfully executed ${pattern.category} fix: ${command}`
        };
      } catch (error) {
        return {
          executed: false,
          command: command,
          result: { error: error.message },
          needsManualIntervention: true,
          reason: `Execution failed: ${error.message}`
        };
      }
    }
  }
  
  // No pattern matched
  return {
    executed: false,
    command: '',
    result: {},
    needsManualIntervention: true,
    reason: `No safe execution pattern found for: ${suggestion}`
  };
}

// Enhanced error suggestion with regex patterns
function suggestFix(taskName, stderr, exitCode = 1) {
  const patterns = [
    // Command not found (exitCode: 127)
    {
      regex: /command not found: (\w+)/i,
      suggestion: (match) => `Install missing command: npm install -D ${match[1]} or check your PATH`,
      category: 'dependency',
      severity: 'high',
      exitCode: 127
    },
    
    // Module resolution
    {
      regex: /Cannot find module ['"]([^'"]+)['"]/i,
      suggestion: (match) => `Install missing module: npm install ${match[1]}`,
      category: 'dependency',
      severity: 'high'
    },
    
    // Network issues
    {
      regex: /ENOTFOUND|ECONNREFUSED|ETIMEDOUT/i,
      suggestion: () => 'Check network connection, DNS settings, or proxy configuration',
      category: 'network',
      severity: 'medium'
    },
    
    // TypeScript errors
    {
      regex: /Unexpected any\. Specify a different type/i,
      suggestion: () => 'Replace "any" with specific TypeScript types (string, number, object, etc.)',
      category: 'typescript',
      severity: 'low'
    },
    
    // React Hooks errors
    {
      regex: /React Hook .* cannot be called at the top level/i,
      suggestion: () => 'Move React Hooks inside component functions, not at top level',
      category: 'react',
      severity: 'high'
    },
    
    {
      regex: /React Hook .* has a missing dependency/i,
      suggestion: () => 'Add missing dependencies to useEffect dependency array or wrap in useCallback',
      category: 'react',
      severity: 'medium'
    },
    
    // Build tool errors
    {
      regex: /tailwindcss.*not found|Tailwind.*error/i,
      suggestion: () => 'Install Tailwind CSS: npm install -D tailwindcss && npx tailwindcss init',
      category: 'build',
      severity: 'high'
    },
    
    {
      regex: /ESLint.*configuration|eslintrc.*error/i,
      suggestion: () => 'Check ESLint config syntax in .eslintrc.js or eslint.config.js',
      category: 'linting',
      severity: 'medium'
    },
    
    // Syntax errors
    {
      regex: /SyntaxError: Unexpected token/i,
      suggestion: () => 'Check syntax at reported line - missing comma, bracket, or quote',
      category: 'syntax',
      severity: 'high'
    },
    
    // Permission errors
    {
      regex: /EACCES|permission denied/i,
      suggestion: () => 'Fix file permissions: chmod +x filename or run with sudo (be careful)',
      category: 'permissions',
      severity: 'medium'
    },
    
    // Port/process errors
    {
      regex: /EADDRINUSE.*port (\d+)/i,
      suggestion: (match) => `Port ${match[1]} is in use. Kill process: lsof -ti:${match[1]} | xargs kill -9`,
      category: 'process',
      severity: 'medium'
    },
    
    // Git errors
    {
      regex: /fatal: not a git repository/i,
      suggestion: () => 'Initialize git repository: git init',
      category: 'git',
      severity: 'low'
    }
  ];

  // Check patterns
  for (const pattern of patterns) {
    if (pattern.exitCode && exitCode !== pattern.exitCode) continue;
    
    const match = stderr.match(pattern.regex);
    if (match) {
      const suggestion = typeof pattern.suggestion === 'function' 
        ? pattern.suggestion(match) 
        : pattern.suggestion;
      
      return {
        suggestion,
        category: pattern.category,
        severity: pattern.severity
      };
    }
  }

  // Task-specific fallbacks
  const taskFallbacks = {
    'build-css': 'Check Tailwind installation and config',
    'lint': 'Check ESLint config and file patterns',
    'test': 'Check test framework setup and dependencies',
    'deploy': 'Check deployment credentials and config'
  };

  const fallback = taskFallbacks[taskName] || 'Check the error message and consult the documentation';
  
  return {
    suggestion: fallback,
    category: 'general',
    severity: 'medium'
  };
}

// Execute a task with agent-like behavior
async function runTask(taskName, config, taskArgs = {}) {
  const task = config.tasks[taskName];
  if (!task) {
    console.error(`Task '${taskName}' not found`);
    process.exit(1);
  }

  console.log(`üîß Running task: ${taskName}`);
  log(`Task description: ${task.description}`);
  
  // Simple approach: extract the actual command from the task
  let actualCommand = '';
  
  if (taskName === 'build-css') {
    actualCommand = 'npx tailwindcss -i src/index.css -o dist/output.css --minify';
  } else if (taskName === 'lint') {
    actualCommand = 'npx eslint "src/**/*.{js,jsx,ts,tsx}"';
  } else if (taskName === 'test') {
    actualCommand = 'npm test';
  } else if (taskName === 'deploy') {
    actualCommand = 'vercel --prod --confirm';
  } else if (taskName === 'plan') {
    const feature = taskArgs.inputFeature || 'New feature';
    console.log(JSON.stringify({
      tasks: [
        {
          name: `Create component for ${feature}`,
          filePaths: [`src/components/${feature.replace(/\s+/g, '')}.tsx`],
          type: 'code',
          deps: []
        },
        {
          name: `Add tests for ${feature}`,
          filePaths: [`src/components/__tests__/${feature.replace(/\s+/g, '')}.test.tsx`],
          type: 'test',
          deps: ['Create component']
        },
        {
          name: `Update documentation for ${feature}`,
          filePaths: ['README.md'],
          type: 'docs',
          deps: ['Create component']
        }
      ]
    }, null, 2));
    console.log(`‚úî [${taskName}] completed`);
    return;
  } else if (taskName === 'post-plan') {
    const pr = taskArgs.inputPRNumber || 0;
    const planTasks = JSON.parse(taskArgs.inputPlanJson || '{"tasks":[]}');
    console.log(`https://github.com/owner/repo/pull/${pr}#issuecomment-123456`);
    console.log(`‚úî [${taskName}] completed`);
    return;
  }
  
  if (!actualCommand) {
    console.error(`Unknown task: ${taskName}`);
    process.exit(1);
  }
  
  // Execute the command
  const result = await executeCommand(actualCommand);
  
  if (result.exitCode !== 0) {
    console.error(`‚úñ [${taskName}] failed (exit code: ${result.exitCode})`);
    if (result.stderr) {
      console.error(result.stderr);
    }
    
    // Get suggestion from Caca-like logic
    const suggestion = suggestFix(taskName, result.stderr, result.exitCode);
    console.log(`‚Üí [Caca] Suggestion: "${suggestion.suggestion}" (${suggestion.category}/${suggestion.severity})`);
    
    process.exit(result.exitCode);
  } else {
    if (result.stdout) {
      console.log(result.stdout);
    }
    console.log(`‚úî [${taskName}] completed (exit code 0)`);
  }
}

// Execute composite task
async function runCompositeTask(taskName, config) {
  const compositeTask = config.composite_tasks[taskName];
  if (!compositeTask) {
    console.error(`Composite task '${taskName}' not found`);
    process.exit(1);
  }

  console.log(`üîß Running composite task: ${taskName}`);
  log(`Starting composite '${taskName}' with steps [${compositeTask.steps.join(', ')}]`);

  for (const step of compositeTask.steps) {
    try {
      await runTask(step, config);
    } catch (error) {
      console.error(`Composite task '${taskName}' failed at step '${step}'`);
      process.exit(1);
    }
  }

  console.log(`‚úî [${taskName}] completed (exit code 0)`);
}

// Handle invoke command for direct agent testing
async function handleInvoke(args, config) {
  let agentName, functionName, argsJson;
  
  for (let i = 0; i < args.length; i++) {
    if (args[i] === '--agent' && i + 1 < args.length) {
      agentName = args[i + 1];
    } else if (args[i] === '--function' && i + 1 < args.length) {
      functionName = args[i + 1];
    } else if (args[i] === '--args' && i + 1 < args.length) {
      argsJson = args[i + 1];
    }
  }
  
  if (!agentName || !functionName || !argsJson) {
    console.error('Usage: pulser invoke --agent <agent> --function <function> --args <json>');
    process.exit(1);
  }
  
  try {
    const parsedArgs = JSON.parse(argsJson);
    log(`Invoking ${agentName}.${functionName} with args: ${JSON.stringify(parsedArgs)}`);
    
    let result = {};
    
    if (agentName === 'BasherExec' && functionName === 'run') {
      result = await executeCommand(parsedArgs.cmd);
    } else if (agentName === 'Caca' && functionName === 'suggest') {
      result = suggestFix(parsedArgs.taskName, parsedArgs.stderr, parsedArgs.exitCode);
    } else if (agentName === 'MayaPlan' && functionName === 'planFeature') {
      result = {
        tasks: [
          {
            name: `Create component for ${parsedArgs.feature}`,
            filePaths: [`src/components/${parsedArgs.feature.replace(/\s+/g, '')}.tsx`],
            type: 'code',
            deps: []
          },
          {
            name: `Add tests for ${parsedArgs.feature}`,
            filePaths: [`src/components/__tests__/${parsedArgs.feature.replace(/\s+/g, '')}.test.tsx`],
            type: 'test',
            deps: ['Create component']
          },
          {
            name: `Update documentation for ${parsedArgs.feature}`,
            filePaths: ['README.md'],
            type: 'docs',
            deps: ['Create component']
          }
        ]
      };
    } else if (agentName === 'Claudia' && functionName === 'postPlan') {
      result = await postToGitHub(
        parsedArgs.prNumber, 
        parsedArgs.planTasks, 
        parsedArgs.owner || 'owner', 
        parsedArgs.repo || 'repo'
      );
    } else if (agentName === 'Patcha' && functionName === 'executeFix') {
      result = await executeFixSuggestion(
        parsedArgs.suggestion,
        parsedArgs.category,
        parsedArgs.severity,
        parsedArgs.taskName,
        parsedArgs.context
      );
    } else {
      console.error(`Unknown agent/function: ${agentName}.${functionName}`);
      process.exit(1);
    }
    
    console.log(JSON.stringify(result, null, 2));
  } catch (error) {
    console.error(`Error invoking agent: ${error.message}`);
    process.exit(1);
  }
}

// Initialize a new pulser project
async function initializeProject() {
  const configPath = path.join(process.cwd(), 'pulser.yaml');
  
  if (fs.existsSync(configPath)) {
    console.error('‚ùå pulser.yaml already exists in this directory');
    process.exit(1);
  }
  
  // Detect project type
  const packageJsonPath = path.join(process.cwd(), 'package.json');
  let projectName = 'my-project';
  let isReactProject = false;
  
  if (fs.existsSync(packageJsonPath)) {
    try {
      const pkg = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
      projectName = pkg.name || 'my-project';
      isReactProject = !!(pkg.dependencies?.react || pkg.devDependencies?.react);
    } catch (error) {
      console.warn('Could not parse package.json');
    }
  }
  
  const template = `name: ${projectName}
version: 1.0.0

environment:
  required:
    - node
    - npm${isReactProject ? '\n    - tailwindcss' : ''}

agents:
  BasherExec: pulser_agents/basher_exec.yaml
  Caca: pulser_agents/caca.yaml
  MayaPlan: pulser_agents/maya_plan.yaml
  Claudia: pulser_agents/claudia.yaml

tasks:
  ${isReactProject ? `build-css:
    description: "Compile Tailwind CSS"
    run: |
      response=$(pulser invoke --agent BasherExec --function run \\
        --args '{"cmd":"npx tailwindcss -i src/index.css -o dist/output.css --minify"}')
      exitCode=$(echo "$response" | jq -r '.exitCode')
      stderr=$(echo "$response" | jq -r '.stderr')
      if [ "$exitCode" -ne 0 ]; then
        echo "‚®Ø build-css failed (exit code $exitCode)"
        echo "$stderr"
        suggestion=$(pulser invoke --agent Caca --function suggest \\
          --args '{"taskName":"build-css","stderr":"'"$stderr"'","exitCode":'$exitCode'}' | jq -r '.suggestion')
        echo "‚Üí Suggestion: $suggestion"
        exit $exitCode
      fi
      echo "$response" | jq -r '.stdout'

  ` : ''}lint:
    description: "Run ESLint"
    run: |
      response=$(pulser invoke --agent BasherExec --function run \\
        --args '{"cmd":"npx eslint \\"${isReactProject ? 'src/**/*.{js,jsx,ts,tsx}' : '**/*.js'}\\""}')
      exitCode=$(echo "$response" | jq -r '.exitCode')
      stderr=$(echo "$response" | jq -r '.stderr')
      if [ "$exitCode" -ne 0 ]; then
        echo "‚®Ø lint failed (exit code $exitCode)"
        echo "$stderr"
        suggestion=$(pulser invoke --agent Caca --function suggest \\
          --args '{"taskName":"lint","stderr":"'"$stderr"'","exitCode":'$exitCode'}' | jq -r '.suggestion')
        echo "‚Üí Suggestion: $suggestion"
        exit $exitCode
      fi
      echo "$response" | jq -r '.stdout'

  test:
    description: "Run tests"
    run: |
      response=$(pulser invoke --agent BasherExec --function run \\
        --args '{"cmd":"npm test"}')
      exitCode=$(echo "$response" | jq -r '.exitCode')
      stderr=$(echo "$response" | jq -r '.stderr')
      if [ "$exitCode" -ne 0 ]; then
        echo "‚®Ø test failed (exit code $exitCode)"
        echo "$stderr"
        suggestion=$(pulser invoke --agent Caca --function suggest \\
          --args '{"taskName":"test","stderr":"'"$stderr"'","exitCode":'$exitCode'}' | jq -r '.suggestion')
        echo "‚Üí Suggestion: $suggestion"
        exit $exitCode
      fi
      echo "$response" | jq -r '.stdout'

  plan:
    description: "Generate AI plan for a feature"
    run: |
      result=$(pulser invoke --agent MayaPlan --function planFeature \\
        --args '{"feature":"{{inputFeature}}","repoPath":"."}')
      echo "$result" | jq .

  post-plan:
    description: "Post AI plan to GitHub PR"
    run: |
      pr={{inputPRNumber}}
      planJson='{{inputPlanJson}}'
      owner={{inputOwner:-"owner"}}
      repo={{inputRepo:-"repo"}}
      response=$(pulser invoke --agent Claudia --function postPlan \\
        --args '{"prNumber":'$pr',"planTasks":'$planJson',"owner":"'$owner'","repo":"'$repo'"}')
      echo "$response" | jq -r '.commentUrl // .error'

composite_tasks:
  ci:
    description: "${isReactProject ? 'build ‚Üí lint ‚Üí test' : 'lint ‚Üí test'}"
    steps:${isReactProject ? '\n      - build-css' : ''}
      - lint
      - test
`;

  try {
    fs.writeFileSync(configPath, template);
    console.log('‚úÖ Created pulser.yaml');
    
    // Create agent configs directory
    const agentsDir = path.join(process.cwd(), 'pulser_agents');
    if (!fs.existsSync(agentsDir)) {
      fs.mkdirSync(agentsDir);
      console.log('‚úÖ Created pulser_agents/ directory');
      
      // Copy agent configs (simplified for init)
      console.log('üìù To complete setup, copy agent configs from pulser installation');
      console.log('   or run: pulser doctor to check configuration');
    }
    
    console.log('üéâ Pulser initialized successfully!');
    console.log('   Run: pulser inspect to verify configuration');
    console.log('   Run: pulser status to check project status');
    
  } catch (error) {
    console.error(`‚ùå Failed to create pulser.yaml: ${error.message}`);
    process.exit(1);
  }
}

// Run comprehensive environment and configuration check
async function runDoctorCheck() {
  console.log('üîç Pulser Doctor - Diagnostic Report\n');
  
  let allGood = true;
  
  // Check Node.js
  const nodeVersion = process.version;
  const majorVersion = parseInt(nodeVersion.slice(1).split('.')[0]);
  console.log(`Node.js: ${nodeVersion} ${majorVersion >= 18 ? '‚úÖ' : '‚ùå'}`);
  if (majorVersion < 18) {
    console.log('   Recommended: Node.js 18+ for best compatibility');
    allGood = false;
  }
  
  // Check pulser.yaml
  const configPath = path.join(process.cwd(), 'pulser.yaml');
  console.log(`pulser.yaml: ${fs.existsSync(configPath) ? '‚úÖ' : '‚ùå'}`);
  if (!fs.existsSync(configPath)) {
    console.log('   Run: pulser init to create configuration');
    allGood = false;
  } else {
    try {
      const config = yaml.load(fs.readFileSync(configPath, 'utf8'));
      console.log(`  Tasks defined: ${Object.keys(config.tasks || {}).length}`);
      console.log(`  Agents configured: ${Object.keys(config.agents || {}).length}`);
      
      // Check agent configs
      if (config.agents) {
        for (const [name, agentPath] of Object.entries(config.agents)) {
          const fullAgentPath = path.join(process.cwd(), agentPath);
          const exists = fs.existsSync(fullAgentPath);
          console.log(`  Agent ${name}: ${exists ? '‚úÖ' : '‚ùå'}`);
          if (!exists) allGood = false;
        }
      }
    } catch (error) {
      console.log(`  YAML parsing: ‚ùå ${error.message}`);
      allGood = false;
    }
  }
  
  // Check environment requirements
  if (fs.existsSync(configPath)) {
    try {
      const config = yaml.load(fs.readFileSync(configPath, 'utf8'));
      if (config.environment?.required) {
        for (const cmd of config.environment.required) {
          try {
            const result = await executeCommand(`which ${cmd}`);
            console.log(`${cmd}: ${result.exitCode === 0 ? '‚úÖ' : '‚ùå'}`);
            if (result.exitCode !== 0) allGood = false;
          } catch (error) {
            console.log(`${cmd}: ‚ùå (check failed)`);
            allGood = false;
          }
        }
      }
    } catch (error) {
      // Already handled above
    }
  }
  
  // Check GitHub integration
  const hasGitHubToken = !!process.env.GITHUB_TOKEN;
  console.log(`GitHub Token: ${hasGitHubToken ? '‚úÖ' : '‚ö†Ô∏è'}`);
  if (!hasGitHubToken) {
    console.log('   Set GITHUB_TOKEN environment variable for PR integration');
  }
  
  // Check dependencies
  const packageJsonPath = path.join(process.cwd(), 'package.json');
  if (fs.existsSync(packageJsonPath)) {
    try {
      const pkg = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
      console.log(`Project: ${pkg.name || 'unnamed'} v${pkg.version || '0.0.0'}`);
      
      const hasReact = !!(pkg.dependencies?.react || pkg.devDependencies?.react);
      const hasTailwind = !!(pkg.dependencies?.tailwindcss || pkg.devDependencies?.tailwindcss);
      const hasEslint = !!(pkg.dependencies?.eslint || pkg.devDependencies?.eslint);
      
      console.log(`  React: ${hasReact ? '‚úÖ' : '‚ûñ'}`);
      console.log(`  Tailwind CSS: ${hasTailwind ? '‚úÖ' : '‚ûñ'}`);
      console.log(`  ESLint: ${hasEslint ? '‚úÖ' : '‚ûñ'}`);
    } catch (error) {
      console.log(`package.json: ‚ùå (parse error)`);
    }
  } else {
    console.log(`package.json: ‚ûñ`);
  }
  
  console.log(`\n${allGood ? 'üéâ' : '‚ö†Ô∏è'} Overall Status: ${allGood ? 'All systems ready!' : 'Issues detected'}`);
  
  if (!allGood) {
    console.log('\nRecommendations:');
    console.log('- Fix issues marked with ‚ùå');
    console.log('- Run: pulser init (if no pulser.yaml)');
    console.log('- Install missing dependencies');
    console.log('- Set environment variables');
  }
}

// Main command handler
async function main() {
  const config = loadConfig();

  switch (command) {
    case 'inspect':
      console.log('Configuration loaded successfully:');
      console.log(`  Name: ${config.name}`);
      console.log(`  Version: ${config.version}`);
      console.log(`  Tasks: ${Object.keys(config.tasks || {}).join(', ')}`);
      console.log(`  Composite tasks: ${Object.keys(config.composite_tasks || {}).join(', ')}`);
      console.log(`  Agents: ${Object.keys(config.agents || {}).join(', ')}`);
      break;

    case 'status':
      console.log('Pulser Task Runner Status:');
      console.log(`  Project: ${config.name} v${config.version}`);
      console.log(`  Tasks available: ${Object.keys(config.tasks || {}).length}`);
      console.log(`  Composite tasks: ${Object.keys(config.composite_tasks || {}).length}`);
      console.log(`  Agents loaded: ${Object.keys(config.agents || {}).length}`);
      break;

    case 'run':
      if (!taskName) {
        console.error('Please specify a task name');
        process.exit(1);
      }

      // Parse task arguments
      const taskArgs = {};
      for (let i = 3; i < args.length; i++) {
        if (args[i] === '--args' && i + 1 < args.length) {
          try {
            Object.assign(taskArgs, JSON.parse(args[i + 1]));
          } catch (error) {
            console.error(`Error parsing task args: ${error.message}`);
            process.exit(1);
          }
        }
      }

      // Check if it's a composite task first
      if (config.composite_tasks && config.composite_tasks[taskName]) {
        await runCompositeTask(taskName, config);
      } else if (config.tasks && config.tasks[taskName]) {
        await runTask(taskName, config, taskArgs);
      } else {
        console.error(`Task '${taskName}' not found`);
        process.exit(1);
      }
      break;

    case 'invoke':
      await handleInvoke(args.slice(1), config);
      break;

    case 'plan':
      // Shortcut for planning
      const feature = args[1] || 'New feature';
      await runTask('plan', config, { inputFeature: feature });
      break;

    case 'post-plan':
      // Shortcut for posting plan
      const pr = args[1];
      const planJson = args[2];
      if (!pr || !planJson) {
        console.error('Usage: pulser post-plan <pr-number> <plan-json>');
        process.exit(1);
      }
      await runTask('post-plan', config, { inputPRNumber: pr, inputPlanJson: planJson });
      break;

    case 'init':
      await initializeProject();
      break;

    case 'doctor':
      await runDoctorCheck();
      break;

    default:
      console.log('Usage: pulser <command> [options]');
      console.log('');
      console.log('Configuration:');
      console.log('  init - Initialize new pulser project');
      console.log('  inspect - Inspect pulser.yaml configuration');
      console.log('  status - Show current status');
      console.log('  doctor - Run diagnostic check');
      console.log('');
      console.log('Task Execution:');
      console.log('  run <task> - Run a task');
      console.log('  invoke --agent <agent> --function <func> --args <json> - Invoke agent');
      console.log('');
      console.log('AI Features:');
      console.log('  plan "<feature>" - Generate AI plan for a feature');
      console.log('  post-plan <pr> <plan-json> - Post plan to GitHub PR');
      console.log('');
      console.log('Examples:');
      console.log('  pulser init                              # Initialize project');
      console.log('  pulser run build-css                     # Run build task');
      console.log('  pulser plan "Add user authentication"    # Generate AI plan');
      console.log('  pulser doctor                            # Check environment');
      break;
  }
}

// Run main
main().catch(console.error);